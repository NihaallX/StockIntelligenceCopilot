"""
Explanation API
===============

API endpoints for generating LLM explanations of deterministic signals.

IMPORTANT:
- LLM explanations are OPTIONAL and DOWNSTREAM of signal generation
- Signals are generated by deterministic logic FIRST
- LLM explains the pre-computed results ONLY
- System works perfectly fine without LLM (fallback mode)
"""

from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
import logging

from app.core.llm.explanation_service import ExplanationService
from app.config.settings import settings

logger = logging.getLogger(__name__)
router = APIRouter()

# Initialize explanation service (lazy init)
_explanation_service: Optional[ExplanationService] = None


def get_explanation_service() -> Optional[ExplanationService]:
    """Get or create explanation service instance"""
    global _explanation_service
    
    if not settings.LLM_EXPLANATIONS_ENABLED:
        return None
    
    if not settings.OPENROUTER_API_KEY:
        logger.warning("LLM explanations enabled but OPENROUTER_API_KEY not set")
        return None
    
    if _explanation_service is None:
        _explanation_service = ExplanationService(
            api_key=settings.OPENROUTER_API_KEY,
            model=settings.OPENROUTER_MODEL,
            enabled=True
        )
    
    return _explanation_service


# Request/Response Models
class KeyLevels(BaseModel):
    """Key price levels for signal"""
    VWAP: Optional[float] = None
    invalidation: Optional[float] = None


class SignalData(BaseModel):
    """Pre-computed deterministic signal"""
    bias: str = Field(..., description="Signal direction: long, short, no_trade")
    confidence: int = Field(..., ge=0, le=100, description="Confidence score 0-100")
    method: str = Field(default="VWAP + Volume", description="Method used")
    keyLevels: Optional[KeyLevels] = None


class MCPContextData(BaseModel):
    """Market Context Protocol output"""
    regime: Optional[str] = Field(None, description="Market regime: trending, mean-reverting, choppy, low-liquidity")
    indexAlignment: Optional[str] = Field(None, description="Index alignment: aligned, diverging, neutral")
    volumeState: Optional[str] = Field(None, description="Volume state: expansion, normal, dry")
    sessionTime: Optional[str] = Field(None, description="Session time: early open, lunch compression, closing expansion")


class PriceData(BaseModel):
    """Optional recent price data"""
    current: Optional[float] = None
    vwap: Optional[float] = None


class ExplainVWAPRequest(BaseModel):
    """Request for VWAP signal explanation"""
    ticker: str = Field(..., description="Stock symbol (e.g., RELIANCE.NS)")
    signal: SignalData = Field(..., description="Pre-computed deterministic signal")
    mcp_context: Optional[MCPContextData] = Field(None, description="Market Context Protocol output")
    price_data: Optional[PriceData] = Field(None, description="Recent price data")


class ExplainVWAPResponse(BaseModel):
    """Response with plain-English explanation"""
    explanation: str = Field(..., description="Plain-English explanation")
    what_went_right: List[str] = Field(..., description="Supporting factors")
    what_could_go_wrong: List[str] = Field(..., description="Risk factors")
    confidence_label: str = Field(..., description="high, medium, or low")
    fallback: bool = Field(..., description="True if LLM unavailable (used template)")
    
    # Metadata
    disclaimer: str = Field(
        default="This is an AI interpretation of pre-computed deterministic signals. It is not financial advice."
    )


@router.post("/vwap", response_model=ExplainVWAPResponse)
async def explain_vwap_signal(request: ExplainVWAPRequest):
    """
    Generate plain-English explanation for a VWAP + Volume signal
    
    **IMPORTANT:**
    - This endpoint explains PRE-COMPUTED signals
    - The signal was generated by deterministic logic FIRST
    - The LLM explains the existing result, it does NOT generate new signals
    - If LLM is unavailable, a template-based fallback is used
    - The system works perfectly fine without this endpoint
    
    **Process:**
    1. Signal generated by VWAP + Volume method (deterministic)
    2. Market Context Protocol (MCP) fetches regime/volume data
    3. THIS endpoint explains the results in plain English
    
    **Returns:**
    - Plain-English explanation
    - What went right (supporting factors)
    - What could go wrong (risk factors)
    - Confidence label (high/medium/low)
    - Fallback flag (true if LLM unavailable)
    """
    try:
        service = get_explanation_service()
        
        if not service:
            # LLM disabled or not configured, use fallback
            logger.info(f"LLM explanations disabled, using fallback for {request.ticker}")
            result = ExplanationService(api_key="", enabled=False)._get_fallback_explanation(
                signal=request.signal.model_dump(),
                mcp_context=request.mcp_context.model_dump() if request.mcp_context else None
            )
            return ExplainVWAPResponse(**result)
        
        # Call LLM explanation service
        result = await service.explain_vwap_signal(
            ticker=request.ticker,
            signal=request.signal.model_dump(),
            mcp_context=request.mcp_context.model_dump() if request.mcp_context else None,
            price_data=request.price_data.model_dump() if request.price_data else None
        )
        
        if not result:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to generate explanation"
            )
        
        return ExplainVWAPResponse(**result)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Explanation endpoint error for {request.ticker}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Explanation generation failed: {str(e)}"
        )


@router.get("/health")
async def health_check():
    """Check if explanation service is available"""
    service = get_explanation_service()
    
    return {
        "enabled": settings.LLM_EXPLANATIONS_ENABLED,
        "configured": bool(settings.OPENROUTER_API_KEY),
        "service_ready": service is not None,
        "model": settings.OPENROUTER_MODEL,
        "fallback_available": True  # Always true - we have template fallback
    }
